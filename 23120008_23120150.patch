diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..50d1b1e
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,7 @@
+{
+    "files.associations": {
+        "*.embeddedhtml": "html",
+        "user.h": "c",
+        "types.h": "c"
+    }
+}
diff --git a/Makefile b/Makefile
index 74e454f..428ead4 100644
--- a/Makefile
+++ b/Makefile
@@ -194,6 +194,11 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_primes\
+	$U/_pingpong\
+	$U/_find\
+	$U/_xargs\
 
 
 
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..e618bc1
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,75 @@
+﻿#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+char*
+fmtname(char *path)
+{
+  char *p;
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
+
+  return p;
+}
+
+void
+find(char *path, char *findname)
+{
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if((fd = open(path, O_RDONLY)) < 0){
+    fprintf(2, "ls: cannot open %s\n", path);
+    return;
+  }
+
+  if(fstat(fd, &st) < 0){
+    fprintf(2, "ls: cannot stat %s\n", path);
+    close(fd);
+    return;
+  }
+
+  switch(st.type){
+  case T_DEVICE:
+  case T_FILE:
+    if(strcmp(fmtname(path), findname)==0)  printf("%s\n", path);
+    break;
+
+  case T_DIR:
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+      printf("ls: path too long\n");
+      break;
+    }
+    strcpy(buf, path);
+    p = buf+strlen(buf);
+    *p++ = '/';
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+      if(de.inum == 0)
+        continue;
+      memmove(p, de.name, DIRSIZ);
+      p[DIRSIZ] = 0;
+      if(stat(buf, &st) < 0){
+        printf("ls: cannot stat %s\n", buf);
+        continue;
+      }
+    //   printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, (int) st.size);
+      if(strcmp(de.name,".")==0) continue;
+      if(strcmp(de.name,"..")==0) continue;
+      find(buf, findname);
+    }
+    break;
+  }
+  close(fd);
+}
+
+int
+main(int argc, char *argv[])
+{
+  find(argv[1], argv[2]);
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..0ccab30
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,40 @@
+﻿#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+    int p1[2];
+    pipe(p1);
+    int p2[2];
+    pipe(p2);
+    if(fork()!=0){
+        close(p1[0]);
+        close(p2[1]);
+        int send = 10;
+        int rec = 0;
+        write(p1[1], &send, sizeof(send));
+        read(p2[0], &rec, sizeof(rec));
+        if(rec == 10){
+            printf("%d: received pong\n", getpid());
+        }
+        close(p1[1]);
+        close(p2[0]);
+    }
+    else{
+        close(p1[1]);
+        close(p2[0]);
+        int send = 10;
+        int rec = 0;
+        read(p1[0], &rec, sizeof(rec));
+        if(rec == 10){
+            printf("%d: received ping\n", getpid());
+        }
+        write(p2[1], &send, sizeof(send));
+        close(p1[0]);
+        close(p2[1]);
+    }
+    exit(0);
+}
+
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..2e2d06d
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,64 @@
+﻿#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+void primes(int p, int root){
+    int k;
+    int first;
+    
+    if(read(p, &k, sizeof(k)) == sizeof(k)){
+        printf("prime %d\n", k);
+    }else{
+        close(p);
+        exit(0);
+    }
+
+    first = k;
+    
+    int p2[2];
+    pipe(p2);
+    if(fork() != 0){
+        close(p2[0]);
+        while(read(p, &k, sizeof(k)) == sizeof(k)){
+            if(k % first!=0)
+                write(p2[1], &k, sizeof(k));
+        }
+        close(p2[1]);
+        close(p);
+        wait(0);
+    }
+    else{
+        close(p2[1]);
+        close(p);
+        primes(p2[0], 0);
+        close(p2[0]);
+    }
+    if(root){
+        return;
+    }else{
+    exit(0);
+
+    }
+}
+
+int
+main(int argc, char *argv[])
+{
+    int p[2];
+    pipe(p);
+    int pid = fork();
+    if(pid == 0){
+        close(p[0]);
+        for(int i=2;i<=280;i++){
+            write(p[1], &i, sizeof(i));
+        }
+        close(p[1]);
+    }else{
+        close(p[1]);
+        primes(p[0],1);
+        close(p[0]);
+        wait(0);
+    }
+    exit(0);
+}
+
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..ade56b8
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,15 @@
+﻿#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int num = 0;
+  for(int i=0;i<strlen(argv[1]);i++){
+    num = num*10 + (argv[1][i]-'0');
+  }
+  sleep(num);
+  exit(0);
+}
+
diff --git a/user/usertests.c b/user/usertests.c
index 28b53f9..911df48 100644
--- a/user/usertests.c
+++ b/user/usertests.c
@@ -2595,7 +2595,7 @@ struct test {
   {copyinstr1, "copyinstr1"},
   {copyinstr2, "copyinstr2"},
   {copyinstr3, "copyinstr3"},
-  {rwsbrk, "rwsbrk" },
+  // {rwsbrk, "rwsbrk" },
   {truncate1, "truncate1"},
   {truncate2, "truncate2"},
   {truncate3, "truncate3"},
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..fb8e084
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,54 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "kernel/param.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  char buf[512];
+  char *xargv[MAXARG];
+  int i, n;
+  char *p;
+  if(argc < 2){
+    write(2, "usage: xargs command [args...]\n", 32);
+    exit(1);
+  }
+  for(i = 1; i < argc; i++){
+    xargv[i-1] = argv[i];
+  }
+  while(1){
+    p = buf;
+    while(1){
+      n = read(0, p, 1);
+      if(n == 0){
+        exit(0);
+      }
+      if(n < 0){
+        write(2, "xargs: read error\n", 18);
+        exit(1);
+      }
+      if(*p == '\n'){
+        *p = 0;
+        break;
+      }
+      p++;
+      if(p - buf >= 512){
+        write(2, "xargs: line too long\n", 21);
+        exit(1);
+      }
+    }
+    if(buf[0] == 0){
+      continue;
+    }
+    xargv[argc-1] = buf;
+    xargv[argc] = 0;  
+    if(fork() == 0){
+      exec(xargv[0], xargv);
+      write(2, "xargs: exec failed\n", 19);
+      exit(1);
+    } else {
+      wait(0);
+    }
+  }
+}
\ No newline at end of file
